% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/detect.R
\name{str_starts}
\alias{str_starts}
\alias{str_ends}
\title{Detect the presence or absence of a pattern at the beginning or end of a
string.}
\usage{
str_starts(string, pattern, negate = FALSE)

str_ends(string, pattern, negate = FALSE)
}
\arguments{
\item{string}{\verb{character vector} of strings.}

\item{pattern}{\code{character}, a pattern with which the string should start
or end.

Can be:
\itemize{
\item A Perl-compatible regular expression (default).
\item Wrap with \code{perl(ignore_case = TRUE)} to use case-insensitive matching.
\item Wrap with \code{fixed()} to use a fixed/literal match.
\item Wrap with \code{regex()} to use a POSIX 1003.2 extended regular expression.
\item Wrap with \code{regex(ignore_case = TRUE)} to use case-insensitive matching with
a POSIX 1003.2 extended regular expression.
}}

\item{negate}{\code{logical}, if \code{TRUE} return non-matching elements. Default is
\code{FALSE}.}
}
\value{
Returns a \verb{logical vector} the same length as \code{string}.
}
\description{
Vectorised over \code{string} and \code{pattern}, though using vectorised
patterns is relatively slow compared to \code{stringr}.
}
\examples{
fruit <- c("apple", "banana", "pear", "pineapple")
str_starts(fruit, "p")
str_starts(fruit, "p", negate = TRUE)
str_ends(fruit, "e")
str_ends(fruit, "e", negate = TRUE)

}
\seealso{
\code{\link[=str_detect]{str_detect()}} which this function wraps.
}
