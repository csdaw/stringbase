% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/detect.R
\name{str_detect}
\alias{str_detect}
\title{Detect the presence or absence of a pattern in a string}
\usage{
str_detect(string, pattern, negate = FALSE)
}
\arguments{
\item{string}{\verb{character vector} of strings.}

\item{pattern}{\code{string} or \verb{character vector}, pattern(s) to match. Can be:
\itemize{
\item A Perl-compatible regular expression (default).
\item Wrap with \code{perl(ignore_case = TRUE)} to use case-insensitive matching.
\item Wrap with \code{fixed()} to use a fixed/literal match.
\item Wrap with \code{regex()} to use a POSIX 1003.2 extended regular expression.
\item Wrap with \code{regex(ignore_case = TRUE)} to use case-insensitive matching with
a POSIX 1003.2 extended regular expression.
}}

\item{negate}{\code{logical}, if \code{TRUE} return non-matching elements. Default is
\code{FALSE}.}
}
\value{
Returns a \verb{logical vector} the same length as \code{string}.
}
\description{
Vectorised over \code{string} and \code{pattern}, though using vectorised
patterns is relatively slow compared to \code{stringr}.
Equivalent to \code{grepl(pattern, x)}.
See \code{str_which()} for an equivalent to \code{grep(pattern, x)}.
}
\examples{
fruit <- c("apple", "banana", "pear", "pineapple")
str_detect(fruit, "a")
str_detect(fruit, "^a")
str_detect(fruit, "a$")
str_detect(fruit, "b")
str_detect(fruit, "[aeiou]")

# Also vectorised over pattern
str_detect("aecfg", letters)

# Returns TRUE if the pattern do NOT match
str_detect(fruit, "^p", negate = TRUE)

}
